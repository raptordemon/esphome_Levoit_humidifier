esphome:
  name: lv451sbridge
  friendly_name: LV451S Bridge

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_FREERTOS_UNICORE: y
#the unicore is needed to reflash the onboard esp32
logger:
  level: DEBUG
  baud_rate: 0   # free up hardware UART

api:
  encryption:
    key: !secret 451sapikey

ota:
  - platform: esphome
    password: !secret 451otakey

wifi:
  ssid: !secret ssid_Wifi
  password: !secret password_Wifi

  ap:
    ssid: "451sBridge"
    password: !secret 451appassword

captive_portal:

# -------------------------------------------------------------------
# Globals – command sequence and "saved" values
# -------------------------------------------------------------------
globals:
  - id: lv_cmd_seq
    type: int
    initial_value: '0x20'

  # Last humidity target used in AUTO (mode_family 0)
  - id: lv_saved_target_humidity
    type: int
    initial_value: '50'

  # Last manual fan level (1–8) used when not in sleep
  - id: lv_saved_cool_level
    type: int
    initial_value: '1'
  
# -------------------------------------------------------------------
# UART: ESP32 <-> LV451S main MCU
# -------------------------------------------------------------------
uart:
  id: lv_uart
  tx_pin: GPIO17     # ESP32 TX -> humidifier RX
  rx_pin: GPIO16     # humidifier TX -> ESP32 RX
  baud_rate: 9800
  data_bits: 8
  parity: NONE
  stop_bits: 1

  debug:
    direction: BOTH
    dummy_receiver: true
    after:
      timeout: 50ms
    sequence:
      - lambda: |-
          using std::vector;
          static vector<uint8_t> buffer;

          buffer.insert(buffer.end(), bytes.begin(), bytes.end());

          size_t pos = 0;
          while (pos + 5 <= buffer.size()) {
            if (buffer[pos] != 0xA5) {
              pos++;
              continue;
            }

            bool found = false;
            for (size_t end = pos + 5; end <= buffer.size(); end++) {
              uint32_t s = 0;
              for (size_t i = pos; i < end; i++) s += buffer[i];
              if ((s & 0xFF) == 0xFF) {
                vector<uint8_t> frame(buffer.begin() + pos, buffer.begin() + end);

                // Publish raw frame as hex
                {
                  char hexbuf[256];
                  size_t n = 0;
                  for (size_t i = 0; i < frame.size(); i++) {
                    if (n + 3 >= sizeof(hexbuf)) break;
                    n += sprintf(hexbuf + n, "%02X ", frame[i]);
                  }
                  id(lv_last_frame).publish_state(std::string(hexbuf, n));
                }

                // -----------------------
                // Decode 451S layout frames
                // NOTE: status-like frames appear as A5 02 ... and also A5 12 ... (same layout)
                // NOTE: some frames are 30/31 bytes, others 34 bytes (extra 00 00 09 at end)
                // -----------------------
                // IMPORTANT FIX: mode changes often show up in the shorter (~30 byte) frames,
                // so we must accept >= 25 (enough for mode/fan/warm fields).
                if (frame.size() >= 25 && (frame[1] == 0x02 || frame[1] == 0x12)) {
                  auto get = [&](int idx) -> uint8_t {
                    if (idx < 0 || (size_t) idx >= frame.size()) return 0;
                    return frame[idx];
                  };

                  // Flag fields:
                  //  byte 14: power flag (0 = off, 1 = on / running)
                  //  byte 15: tank flag  (0 = tank present, 1 = tank removed)
                  //  byte 17: display brightness (0x00 = off, 0x64 = on)
                  //  byte 18: "status" / issue flag (0 = OK, 1 = fault: tank removed OR out-of-water)
                  uint8_t power_raw  = get(14);
                  uint8_t tank_flag  = get(15);
                  uint8_t disp_raw   = get(17);
                  uint8_t status_raw = get(18);

                  uint8_t target    = get(19);
                  uint8_t current   = get(20);
                  uint8_t raw_flags = get(21);
                  uint8_t mode_fam  = get(22);
                  uint8_t fan_raw   = get(23);
                  uint8_t warm      = get(24);

                  // Only present on the longest frames; safe to read but don't rely on it.
                  uint8_t fan_mirr  = get(33);
                  (void)raw_flags;
                  (void)fan_mirr;

                  // --- Power state (from panel/app) ---
                  bool power_on = (power_raw == 0x01);
                  id(lv_power).publish_state(power_on);

                  // --- Tank present (fixed polarity) ---
                  bool tank_present = (tank_flag == 0x00);
                  id(lv_tank_present).publish_state(tank_present);

                  // --- Status bit (generic "problem" flag) ---
                  bool status_problem = (status_raw & 0x01);
                  id(lv_status_problem).publish_state(status_problem);

                  // --- Logical water status ---
                  bool water_problem = status_problem && tank_present;
                  id(lv_water_status).publish_state(water_problem);

                  // --- Display ---
                  bool display_on = (disp_raw != 0x00);
                  id(lv_display_on).publish_state(display_on);
                  id(lv_display_switch).publish_state(display_on);

                  // --- Humidity ---
                  id(lv_target_humidity).publish_state((float) target);
                  id(lv_current_humidity).publish_state((float) current);
                  id(lv_target_humidity_number).publish_state((float) target);

                  // --- Mode text (this will now update because we decode the short frames too) ---
                  std::string mode = "unknown";
                  if (mode_fam == 0x00) {
                    mode = "auto";
                    id(lv_manual_mode).publish_state(false);
                    id(lv_sleep_mode).publish_state(false);
                  } else if (mode_fam == 0x01) {
                    mode = "manual";
                    id(lv_manual_mode).publish_state(true);
                    id(lv_sleep_mode).publish_state(false);
                  } else if (mode_fam == 0x02) {
                    mode = "sleep";
                    id(lv_manual_mode).publish_state(false);
                    id(lv_sleep_mode).publish_state(true);
                  }
                  id(lv_mode_text).publish_state(mode);

                  // Save "real" humidity target ONLY in auto mode
                  if (mode_fam == 0x00) {
                    id(lv_saved_target_humidity) = (int) target;
                  }

                  // --- Fan level ---
                  int fan_level = (int) fan_raw;
                  id(lv_cool_level_sensor).publish_state((float) fan_level);
                  id(lv_cool_level_number).publish_state((float) fan_level);

                  if (mode_fam != 0x02 && fan_level >= 1 && fan_level <= 8) {
                    id(lv_saved_cool_level) = fan_level;
                  }

                  // --- Warm level 0–3 ---
                  id(lv_warm_level_sensor).publish_state((float) warm);
                  id(lv_warm_level_number).publish_state((float) warm);
                }

                pos = end;
                found = true;
                break;
              }
            }

            if (!found)
              break;
          }

          if (pos > 0 && pos <= buffer.size())
            buffer.erase(buffer.begin(), buffer.begin() + pos);
          if (buffer.size() > 200)
            buffer.erase(buffer.begin(), buffer.end() - 200);


# -------------------------------------------------------------------
# TEXT SENSORS – raw frames & mode text
# -------------------------------------------------------------------
text_sensor:
  - platform: template
    id: lv_last_frame
    name: "Last Raw Frame"
    icon: "mdi:hexagon-multiple"
    update_interval: never

  - platform: template
    id: lv_mode_text
    name: "Mode"
    icon: "mdi:alpha-m-circle"
    update_interval: never

# -------------------------------------------------------------------
# BINARY SENSORS – tank, water, display state
# -------------------------------------------------------------------
binary_sensor:
  - platform: template
    id: lv_tank_present
    name: "Tank Present"

  - platform: template
    id: lv_status_problem
    name: "Status"
    device_class: problem

  - platform: template
    id: lv_display_on
    name: "Display Status"
    icon: "mdi:monitor"

  - platform: template
    id: lv_water_status
    name: "Water Status"
    device_class: problem
    lambda: |-
      // If the unit is powered OFF, we do not show a water problem.
      if (!id(lv_power).state) {
        return false;
      }

      // If the tank is removed, we also suppress "water problem".
      if (!id(lv_tank_present).state) {
        return false;
      }

      // Tank present + power on → inherit generic Status flag.
      return id(lv_status_problem).state;

# -------------------------------------------------------------------
# SENSORS – humidity, fan, warm
# -------------------------------------------------------------------
sensor:
  - platform: template
    id: lv_current_humidity
    name: "Current Humidity"
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 0

  - platform: template
    id: lv_target_humidity
    name: "Target Humidity"
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 0

  - platform: template
    id: lv_cool_level_sensor
    name: "Cool Mist Level"
    icon: "mdi:fan"
    accuracy_decimals: 0

  - platform: template
    id: lv_warm_level_sensor
    name: "Warm Level"
    icon: "mdi:radiator"
    accuracy_decimals: 0


# -------------------------------------------------------------------
# SWITCHES – sleep/manual flags, power, display
# -------------------------------------------------------------------
switch:

  - platform: template
    id: lv_sleep_mode
    name: "Sleep Mode Toggle"
    icon: "mdi:power-sleep"
    optimistic: true

    turn_on_action:
      - lambda: |-
          // Enter SLEEP mode – 451S uses 82 40
          int target = (int) id(lv_target_humidity).state;
          if (target < 40) target = 40;
          if (target > 80) target = 80;

          uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;

          std::vector<uint8_t> frame = {
            0xA5, 0x22, cmd_id, 0x0A,
            0x00, 0x00,
            0x01, 0x82, 0x40, 0x00,
            (uint8_t) target,
            0x00, 0x00, 0x00, 0x00, 0x00
          };

          uint32_t s = 0;
          for (size_t i = 0; i < frame.size(); i++) if (i != 5) s += frame[i];
          frame[5] = (0xFF - (s & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame.data(), frame.size());

    turn_off_action:
      - lambda: |-
          // SLEEP -> AUTO: 451S uses 29 A1 prep + 80 40 commit
          // 1) prep: 29 A1
          uint8_t cmd_id1 = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame1 = {
            0xA5, 0x22, cmd_id1, 0x0A,
            0x00, 0x00,
            0x01, 0x29, 0xA1, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00
          };
          uint32_t s1 = 0;
          for (size_t i = 0; i < frame1.size(); i++) if (i != 5) s1 += frame1[i];
          frame1[5] = (0xFF - (s1 & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame1.data(), frame1.size());

          // 2) commit AUTO: 80 40 (payload bytes based on your capture)
          uint8_t cmd_id2 = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame2 = {
            0xA5, 0x22, cmd_id2, 0x0A,
            0x00, 0x00,
            0x01, 0x80, 0x40, 0x00,
            0x3C, 0xF1, 0xFE, 0x3F, 0x00, 0x00
          };
          uint32_t s2 = 0;
          for (size_t i = 0; i < frame2.size(); i++) if (i != 5) s2 += frame2[i];
          frame2[5] = (0xFF - (s2 & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame2.data(), frame2.size());

  - platform: template
    id: lv_manual_mode
    name: "Manual Mode Toggle"
    icon: "mdi:hand-back-right"
    optimistic: true

    turn_on_action:
      - lambda: |-
          // AUTO -> MANUAL
          id(lv_saved_target_humidity) = (int) id(lv_target_humidity).state;

          // 1) prep 29 A1
          uint8_t cmd_id1 = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame1 = {
            0xA5, 0x22, cmd_id1, 0x0A,
            0x00, 0x00,
            0x01, 0x29, 0xA1, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00
          };
          uint32_t s1 = 0;
          for (size_t i = 0; i < frame1.size(); i++) if (i != 5) s1 += frame1[i];
          frame1[5] = (0xFF - (s1 & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame1.data(), frame1.size());

          // 2) commit manual via 60 A2 (default fan level = 3)
          int lvl = 3;
          id(lv_saved_cool_level) = lvl;
          uint8_t cmd_id2 = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame2 = {
            0xA5, 0x22, cmd_id2, 0x07,
            0x00, 0x00,
            0x01, 0x60, 0xA2, 0x00,
            0x00, 0x01, (uint8_t) lvl
          };
          uint32_t s2 = 0;
          for (size_t i = 0; i < frame2.size(); i++) if (i != 5) s2 += frame2[i];
          frame2[5] = (0xFF - (s2 & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame2.data(), frame2.size());

    turn_off_action:
      - lambda: |-
          // MANUAL -> AUTO (same pattern as sleep->auto)
          // 1) 29 A1
          uint8_t cmd_id1 = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame1 = {
            0xA5, 0x22, cmd_id1, 0x0A,
            0x00, 0x00,
            0x01, 0x29, 0xA1, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00
          };
          uint32_t s1 = 0;
          for (size_t i = 0; i < frame1.size(); i++) if (i != 5) s1 += frame1[i];
          frame1[5] = (0xFF - (s1 & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame1.data(), frame1.size());

          // 2) commit AUTO via 80 40
          uint8_t cmd_id2 = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame2 = {
            0xA5, 0x22, cmd_id2, 0x0A,
            0x00, 0x00,
            0x01, 0x80, 0x40, 0x00,
            0x3C, 0xF1, 0xFE, 0x3F, 0x00, 0x00
          };
          uint32_t s2 = 0;
          for (size_t i = 0; i < frame2.size(); i++) if (i != 5) s2 += frame2[i];
          frame2[5] = (0xFF - (s2 & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame2.data(), frame2.size());

  # Power – same 00 A0 command as 600s
  - platform: template
    id: lv_power
    name: "Power"
    icon: "mdi:power"
    optimistic: true
    turn_on_action:
      - lambda: |-
          uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame = {
            0xA5, 0x22, cmd_id, 0x05,
            0x00, 0x00,
            0x01, 0x00, 0xA0, 0x00,
            0x01
          };
          uint32_t s = 0;
          for (size_t i = 0; i < frame.size(); i++) if (i != 5) s += frame[i];
          frame[5] = (0xFF - (s & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame.data(), frame.size());
    turn_off_action:
      - lambda: |-
          uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame = {
            0xA5, 0x22, cmd_id, 0x05,
            0x00, 0x00,
            0x01, 0x00, 0xA0, 0x00,
            0x00
          };
          uint32_t s = 0;
          for (size_t i = 0; i < frame.size(); i++) if (i != 5) s += frame[i];
          frame[5] = (0xFF - (s & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame.data(), frame.size());

  # Display – same 05 A1 command as 600s
  - platform: template
    id: lv_display_switch
    name: "Display"
    icon: "mdi:monitor"
    optimistic: true
    turn_on_action:
      - lambda: |-
          uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame = {
            0xA5, 0x22, cmd_id, 0x05,
            0x00, 0x00,
            0x01, 0x05, 0xA1, 0x00,
            0x64
          };
          uint32_t s = 0;
          for (size_t i = 0; i < frame.size(); i++) if (i != 5) s += frame[i];
          frame[5] = (0xFF - (s & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame.data(), frame.size());
    turn_off_action:
      - lambda: |-
          uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;
          std::vector<uint8_t> frame = {
            0xA5, 0x22, cmd_id, 0x05,
            0x00, 0x00,
            0x01, 0x05, 0xA1, 0x00,
            0x00
          };
          uint32_t s = 0;
          for (size_t i = 0; i < frame.size(); i++) if (i != 5) s += frame[i];
          frame[5] = (0xFF - (s & 0xFF)) & 0xFF;
          id(lv_uart).write_array(frame.data(), frame.size());

# -------------------------------------------------------------------
# NUMBERS – target humidity, fan level (manual), warm level
# -------------------------------------------------------------------
number:
  # -----------------------------------------------------------------
  # Target humidity (40–80) – 2-stage E8 A2 + 10 41 transaction
  # -----------------------------------------------------------------
  - platform: template
    id: lv_target_humidity_number
    name: "Target Humidity"
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    min_value: 40
    max_value: 80
    step: 1
    optimistic: true
    set_action:
      - lambda: |-
          int target = (int) x;
          if (target < 40) target = 40;
          if (target > 80) target = 80;

          // ---------- Phase 1: E8 A2 "set target" ----------
          // From sniffer:
          // A5 22 <ID> 06 00 <YY> 01 E8 A2 00 00 <TT>
          // with (sum(all bytes) & 0xFF) == 0xFF

          {
            uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
            id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;

            std::vector<uint8_t> frame = {
              0xA5, 0x22, cmd_id, 0x06,
              0x00, 0x00, 0x01, 0xE8, 0xA2, 0x00, 0x00,
              (uint8_t) target   // TT
            };

            uint32_t s = 0;
            for (size_t i = 0; i < frame.size(); i++) {
              if (i != 5) s += frame[i];
            }
            frame[5] = (0xFF - (s & 0xFF)) & 0xFF;

            id(lv_uart).write_array(frame.data(), frame.size());
          }

          // ---------- Phase 2: 10 41 "apply" ----------
          // From sniffer:
          // A5 22 <ID> 04 00 <YY> 01 10 41 00
          // same checksum rule on index-5

          {
            uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
            id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;

            std::vector<uint8_t> frame = {
              0xA5, 0x22, cmd_id, 0x04,
              0x00, 0x00, 0x01, 0x10, 0x41, 0x00
            };

            uint32_t s = 0;
            for (size_t i = 0; i < frame.size(); i++) {
              if (i != 5) s += frame[i];
            }
            frame[5] = (0xFF - (s & 0xFF)) & 0xFF;

            id(lv_uart).write_array(frame.data(), frame.size());
          }

  # -----------------------------------------------------------------
  # Cool mist level – 13 41, 1–9 (works now)
  # -----------------------------------------------------------------
  - platform: template
    id: lv_cool_level_number
    name: "Cool Mist Level"
    icon: "mdi:fan"
    min_value: 1
    max_value: 9
    step: 1
    optimistic: true
    set_action:
      - lambda: |-
          int level = (int) x;
          if (level < 1) level = 1;
          if (level > 9) level = 9;

          uint8_t cmd_id = (uint8_t) id(lv_cmd_seq);
          id(lv_cmd_seq) = (id(lv_cmd_seq) + 1) & 0xFF;

          std::vector<uint8_t> frame = {
            0xA5, 0x22, cmd_id, 0x08,
            0x00, 0x00,
            0x01, 0x13, 0x41, 0x00,
            (uint8_t) level,
            0x00, 0x00, 0x00
          };

          uint32_t s = 0;
          for (size_t i = 0; i < frame.size(); i++) {
            if (i != 5) s += frame[i];
          }
          frame[5] = (0xFF - (s & 0xFF)) & 0xFF;

          id(lv_uart).write_array(frame.data(), frame.size());


  - platform: template
    name: "Warm Level (0-3)"
    id: lv_warm_level_number
    min_value: 0
    max_value: 3
    step: 1
    optimistic: true
    set_action:
      - lambda: |-
          using std::vector;

          // Keep our own sequence counter for warm commands
          static uint8_t seq = 0x0F;  // starting value, arbitrary but matches your capture range

          // New warm level from HA (0..3)
          uint8_t warm = (uint8_t)x;

          // Checksum rule derived from your app capture:
          // seq + checksum + warm = 0xDB (mod 256)
          uint8_t checksum = (uint8_t)(0xDB - seq - warm);

          std::vector<uint8_t> frame = {
            0xA5,       // header
            0x22,       // app->MCU / write
            seq,        // sequence
            0x09,       // warm-level opcode
            0x00,
            checksum,   // dynamic checksum
            0x01,
            0x12,
            0x41,
            0x00,
            warm,       // 0..3
            0x00, 0x00, 0x00, 0x00
          };

          // Send it on the LV451S UART bus
          id(lv_uart).write_array(frame.data(), frame.size());

          ESP_LOGD("lv451s", "Sent warm cmd: seq=0x%02X warm=%u chk=0x%02X",
                   seq, warm, checksum);

          // Increment sequence for next command, keep it in a "sane" range
          seq++;
          if (seq >= 0x40) {
            seq = 0x0F;  // wrap back into a similar range as the app
          }
